{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Riddler Lottery Search\"\nauthor: \"Ami Wulf\"\ndate: \"11/24/2019\"\noutput: pdf_document\n---\n\nWe start by constructing a dataset with numbers that satisfy the \n2nd and 3rd friends' observations\n\n#Start with all numbers from 1 to 70\nnon_primes <- data.frame(number = 1:70)\n\n#prime factorization code taken from \n#https://stackoverflow.com/questions/49974601/r-prime-factorization\nfind_factorization=function(x){\n  n=c()\n  i=2\n  r=x\n  while(prod(n)!=x){\n    if(!r%%i) {\n      n=c(n,i)\n      r=r/i\n      i=1\n    }\n    i=i+1\n  }\n  n\n}\n\n#Find the factorization of each number, the unique factors in each, \n#and the number of unique factors\nnon_primes$factorization <- sapply(non_primes$number, find_factorization)\nnon_primes$length <- sapply(non_primes$factorization, length)\nnon_primes$unique_factors <- sapply(non_primes$factorization, unique)\nnon_primes$num_unique <- sapply(non_primes$unique_factors, length)\n\n#subset to numbers with 2+ unique factors, a la the 3rd friend's observation,\n#which also excludes the primes, a la the 2nd friend's observation\nnon_primes <- non_primes[non_primes$num_unique >= 2,]\n#This leaves 41 numbers.\n\n########################################################################\n### Given that each number was only picked once, all of their sets of 5\n### numbers have the same product, and that product (like all numbers)\n### can be uniquely expressed as a product of primes, we know that any\n### prime that exists in the prime factorization of one picked set of 5 \n### numbers must exist in the other set of 5 numbers. So we can remove \n### all numbers with a prime that does not show up in at least 5\n### different numbers.\n########################################################################\n\ntable(unlist(non_primes$factorization))\n\n#numbers with 13, 17, 19, 23, 29, and 31 must be removed\n#expression in the sapply picks those rows without (!) any (max) successful \n#finding (%in%) of those primes\nnon_primes <- non_primes[sapply(non_primes$factorization, function(x) \n                         (!max(c(13, 17, 19, 23, 29, 31) %in% x))), ]\n\n########################################################################\n### The leaves 28 potential numbers. Given that the problem implies that\n### there is only one valid product, we must be able to lower these 28 \n### to 25 numbers. Just as we wanted to remove primes that had fewer \n### than 5 instances, we also must remove primes that to not have a \n### multiple of 5 instances. We see that the three we remove must have \n### a total of three 7s in their prime factorization to lower the number \n### of 7s to 5. The same goes for two 5s, so we can start off by\n### removing numbers with 7 and 5 in their prime factorization.\n########################################################################\n\nnon_primes <-  non_primes[!(non_primes$number %in% c(35,70)),]\ntable(unlist(non_primes$factorization))\n\n########################################################################\n### Finally, we are left with one number to remove, and the prime\n### factor list has two 3s and one 7 above multiples of 5 of each. Let's\n### remove 63.\n########################################################################\n\nnon_primes <-  non_primes[!(non_primes$number == 63),]\ntable(unlist(non_primes$factorization))\n\n########################################################################\n### Great, we have the prime factors in the remaining 25 numbers, and\n### can infer an individual 5-number group -- and the product of \n### interest -- by dividing by five. Each 5-group will be made up of the\n### following: seven 2s, four 3s, two 5s, one 7, and one 11. This gives\n### us the answer to the central question:\n########################################################################\n\n#$$2^7 * 3^4 * 5^2 * 7^1 * 11^1 = 19,958,400$$\n\n##################### We can also see this by imagining two valid products.\n##################### If that were the case, one draw of 5 sets of 5 numbers would need to\n##################### be adjusted in some way that changes all 5 friends' products. This\n##################### cannot be possible since there are only 3 unused numbers, so only\n##################### three friends could have their products changed. Thus there can only\n##################### be 25 valid numbers.\n\n\n\n########################################################################\n######################### BONUS QUESTION ###############################\n########################################################################\n\n########################################################################\n### Now that we know the prime factorization of each draw of 5 numbers,\n### we can search for valid such draws, and then valid groups of 5 draws\n### of 5 numbers. The former task will be completed by winnowing down\n### draws of 5 numbers to those that qualify. The latter would take far\n### too long to run (running a series of several operations and checks \n### over a billion times) so we'll a sort of depth-first search, \n### attempting to stop reaching the vast majority of those checks.\n### First, the seach for valid draws of 5 numbers:\n########################################################################\n\n#Gets a list of valid quintets of numbers\nfind_valid_5groups <- function(){\n  #combinatorics function getting all 5-groups of 25 numbers\n  combinations <- combn(25, 5)\n  combinations <- subset_correct_total_length(combinations)\n  combinations <- subset_correct_product(combinations)\n  #return valid 5-groups\n  return(combinations)\n}\n\n#Check each group of 5 numbers to see if they have a total of 15\n#prime factors. A quick time-saver to avoid multiplying 5 numbers and\n#checking the result for each combination\nsubset_correct_total_length <- function(combinations){\n  lengths <- apply(combinations, 2, function(x) sum(non_primes[x,]$length))\n  return(combinations[,lengths == 15])\n}\n\n#Checking each group of 5 numbers to see if their product is our product \n#of interest\nsubset_correct_product <- function(combinations){\n  products <- apply(combinations, 2, function(x) prod(non_primes[x,]$number))\n  return(combinations[,products == 19958400])\n}\n\ncombinations <- find_valid_5groups()\n#275 different draws of 5 result in the correct product.\n\n########################################################################\n### Now, the search for draws of all 25 numbers in which each group of\n### 5 is in our valid group of 275. Checking each potential grouping for \n### validity would take far too long, so we'll create a custom process\n### to cut the number of checks down. The function effectively cuts the\n### vast majority of the checks out of contention before we even get to\n### them.\n########################################################################\n\n#place the 275 valid combinations of 5 numbers into a list\ncombs <- split(combinations, rep(1:ncol(combinations), each = nrow(combinations)))\nworking_5_5_divisions <- NULL\n\n#start the search\nfind_working_5_5_divisions <- function(combs, divs){\n  working_5s_list <- NULL\n  divs <- add_another_5(working_5s_list = working_5s_list, remaining_combs = combs, divs = divs)\n  return(divs)\n}\n\n#For each of the combinations that remain valid when the function is\n#called, and the groups of 5 that we've already selected in this\n#depth-first search, recurse on any new group of 5 that doesn't overlap\n#any of the already-selected groups.\nadd_another_5 <- function(working_5s_list, remaining_combs, divs){\n  n <- length(remaining_combs)\n  #for each of the remaining combinations of 5\n  for(i in 1:n){\n    #add it (the name of the combination) to the working list\n    working_5s_list <- c(working_5s_list, names(remaining_combs[i]))\n    #if that makes a set of 5 groups of 5, add that valid draw to a list\n    #of valid draws\n    if(length(working_5s_list) == 5){\n      divs <- cbind(divs, working_5s_list)\n      #and exit the for loop (as there can only be one valid 5th group of\n      #5 for a given first 4 groups of 5)\n      return(divs)\n    }\n    if(i < n){\n      #find a list of the combinations that would be valid if the current \n      #combination was added to the working list of combinations. This is \n      #decided by checking each of the remaining combinations for intersecting \n      #numbers in the current combination and accepting it as valid if there are \n      #no intersecting numbers\n      non_intersecting <- c(rep(FALSE, i), sapply(remaining_combs[(i+1):n], function(x) \n        length(base::intersect(x, remaining_combs[[i]])) == 0))\n      #If any such valid combinations exist, recurse with those valid combinations\n      #as the new valid list, and with the working group list now including this\n      #new appended group\n      if(sum(non_intersecting) > 0){\n        divs <- add_another_5(working_5s_list, remaining_combs[non_intersecting], divs)\n      }\n      \n    }\n    #if there are no valid combinations, or once the valid ones have been \n    #traversed, continue on in the for loop, removing the group that we appended\n    working_5s_list <- working_5s_list[-length(working_5s_list)]\n  }\n  return(divs)\n}\n\n#Run through this recursive search\nworking_5_5_divisions <- find_working_5_5_divisions(combs, working_5_5_divisions)\nworking_5_5_divisions <- matrix(as.numeric(working_5_5_divisions), nrow = 5)\n\n########################################################################\n### We find 12,781 valid draws of 5 groups of 5 numbers in which all\n### of the friends' numbers have a product of 19,958,400.\n########################################################################\n\n\n\n",
    "created" : 1574656499513.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "124354591",
    "id" : "826B525A",
    "lastKnownWriteTime" : 1574656578,
    "last_content_update" : 1574656578960,
    "path" : "~/Documents/Projects/Riddler/Riddler_lottery_search/Find_draws_and_explanation.Rmd",
    "project_path" : "Find_draws_and_explanation.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}